<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CSharp on Moien Tajik</title><link>/tags/csharp/</link><description>Recent content in CSharp on Moien Tajik</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 10 Jan 2020 20:00:00 +0330</lastBuildDate><atom:link href="/tags/csharp/index.xml" rel="self" type="application/rss+xml"/><item><title>C# Garbage Collector - Part 3</title><link>/posts/2020-01-10-gc-part-3/</link><pubDate>Fri, 10 Jan 2020 20:00:00 +0330</pubDate><guid>/posts/2020-01-10-gc-part-3/</guid><description>&lt;p>This article in the C# garbage collector series outlines the history and types of GC in .NET. It covers three GC modes: &lt;br>&lt;/p>
&lt;ol> &lt;li>&lt;b>Server GC&lt;/b> for server-side applications&lt;/li> &lt;li>&lt;b>Concurrent Workstation GC&lt;/b> for client apps with UI&lt;/li> &lt;li>&lt;b>Non-Concurrent Workstation GC&lt;/b> for single-processor server apps&lt;/li> &lt;/ol>
Each mode is optimized for different scenarios, balancing throughput and responsiveness. The article provides insights into configuring these modes for specific applications, highlighting the importance of choosing the right GC mode based on the application's nature and environment.</description></item><item><title>C# Garbage Collector - Part 2</title><link>/posts/2019-12-12-gc-part-2/</link><pubDate>Thu, 12 Dec 2019 23:00:00 +0330</pubDate><guid>/posts/2019-12-12-gc-part-2/</guid><description>This article delves into the distinction between &lt;strong>Stack&lt;/strong> and &lt;strong>Heap&lt;/strong> in C# memory management. It explains how the stack, with its &lt;code>LIFO&lt;/code> method, stores value types like structs and enums, while the heap handles reference types like &lt;code>strings&lt;/code>. Key concepts like &lt;strong>boxing&lt;/strong> and &lt;strong>unboxing&lt;/strong> are covered, showing how value types can be converted to reference types and vice versa. The article emphasizes the importance of efficient memory management and the role of the garbage collector in .NET, particularly in managing heap memory and optimizing overall application performance.</description></item><item><title>C# Garbage Collector - Part 1</title><link>/posts/2019-11-29-gc-part-1/</link><pubDate>Fri, 29 Nov 2019 21:00:00 +0330</pubDate><guid>/posts/2019-11-29-gc-part-1/</guid><description>This article explores memory management in C# and the garbage collector&amp;rsquo;s role. It differentiates &lt;strong>managed&lt;/strong> languages like C# from &lt;strong>unmanaged&lt;/strong> ones like C and C++, highlighting C#&amp;rsquo;s automatic memory management. Using a simple example, the article shows how C# frees developers from the complexities of manual memory allocation and disposal, allowing them to focus more on business logic. The series aims to provide a comprehensive understanding of the garbage collector in C#, demonstrating its efficiency in managing memory in managed programming environments.</description></item><item><title>C# Internals - Single and SingleOrDefault</title><link>/posts/2019-10-16-csharp-internals-single/</link><pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate><guid>/posts/2019-10-16-csharp-internals-single/</guid><description>This article demystifies the LINQ methods &lt;code>Single&lt;/code> and &lt;code>SingleOrDefault&lt;/code> in C#, addressing the misconception that they always traverse an entire &lt;code>Enumerable&lt;/code>. It explains the actual behavior of these methods, both with and without a predicate, contrasting them with &lt;code>First&lt;/code> and &lt;code>FirstOrDefault&lt;/code>. The article clarifies that &lt;code>SingleOrDefault&lt;/code> efficiently handles different scenarios, such as returning a default value, the only item, or throwing an error when multiple items exist. It emphasizes the operational differences and efficiency &lt;strong>O(1)&lt;/strong> without predicate and &lt;strong>O(N)&lt;/strong> with predicate of these methods, offering valuable insights for C# developers seeking to optimize their code.</description></item></channel></rss>