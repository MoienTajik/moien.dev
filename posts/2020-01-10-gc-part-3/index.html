<!doctype html><html lang=en class="wf-firasans-n4-active wf-active"><head><link href=http://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.121.0"><title>C# Garbage Collector - Part 3 &#183; Moien Tajik</title>
<meta content="Moien Tajik" property="og:site_name"><meta content="C# Garbage Collector - Part 3 - Moien Tajik" property="og:title"><meta content="In this series of articles, we aim to dive into Memory Management in C#, acquaint ourselves with the Garbage Collector, and gain an overall understanding of how it operates." property="og:description"><meta content="./WS-GC.png" property="og:image"><link href="https://fonts.googleapis.com/css?family=Fira+Sans:300,300i,400,400i|Roboto+Mono:300,300i,400,400i" rel=stylesheet><style media=print>.sidebar{display:none!important}.container,.content{width:100%;float:none;display:initial;margin:0 auto}.container{padding-left:1rem;padding-right:1rem}</style><link rel=stylesheet href=/css/poole.css><link rel=stylesheet href=/css/hyde.css><link rel=stylesheet href=/css/custom.css><script defer src=https://use.fontawesome.com/releases/v5.0.13/js/all.js integrity=sha384-xymdQtn1n3lH2wcu0qhcdaOpQwyoarkgLVxC/wZ5q7h9gHtxICrpcaSUfygqZGOe crossorigin=anonymous></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body class=theme-base-te><div class=sidebar><div class="container text-center"><div class="sidebar-about text-center"><img src=/img/Moien%20Tajik.png alt="Moien Tajik's Image" class="img-circle headshot center">
<a href=/ class=no-decoration><h1 class=brand>Moien Tajik</h1></a><p class=lead>Principal Software Engineer</p></div><div><ul class=sidebar-nav><li><a href=/><span>Home</span></a></li><li><a href=/posts/><span>Posts</span></a></li><li><a href=/tags/><span>Tags</span></a></li></li></ul></div><p><section class="row text-center"><a href=https://twitter.com/MoienTajik><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a>
&nbsp;<a href=https://github.com/MoienTajik><i class="fab fa-github fa-lg" aria-hidden=true></i></a>
&nbsp;<a href=https://linkedin.com/in/MoienTajik><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a>
&nbsp;<a href=https://stackoverflow.com/story/moientajik><i class="fab fa-stack-overflow fa-lg" aria-hidden=true></i></a>
&nbsp;<a href=https://medium.com/@MoienTajik><i class="fab fa-medium fa-lg" aria-hidden=true></i></a>
&nbsp;<a href=mailto:moientajik@hotmail.com><i class="fas fa-at fa-lg" aria-hidden=true></i></a></section></p><p class=copyright>&copy; 2024 Moien Tajik</br><a href=https://creativecommons.org/licenses/by/4.0>All rights reserved</a></p></div><div></div></div><div class="content container"><div class=post><h1 class=postTitle>C# Garbage Collector - Part 3</h1><div class="col-sm-12 col-md-12"><span class="text-left post-date meta"><i class="fas fa-calendar-alt"></i> <span class=subtitle>Publish Date: Jan 10, 2020</span><br><i class="fas fa-tags"></i>
Tags:
<a class=meta href=/tags/c>c#</a>
,
<a class=meta href=/tags/csharp>csharp</a>
,
<a class=meta href=/tags/garbage-collector>garbage collector</a>
,
<a class=meta href=/tags/gc>gc</a><br></span></div><hr><p>In the previous <a href=https://moien.dev/posts/2019-12-12-gc-part-2>article</a>, we discussed the differences between stack and heap and concluded that for freeing heap memory without manual intervention, we require the <strong>garbage collector</strong>.</p><hr><h2 id=a-brief-history-of-gc-in-net>A brief history of GC in .NET</h2><p>The genesis of the garbage collector (GC) in .NET dates back to 1990 when Microsoft was developing its version of JavaScript, named JScript. Initially developed by a four-person team, one member, <a href=https://www.zdnet.com/article/microsoft-big-brains-patrick-dussud>Patrick Dussud</a>, who is recognized as the father of .NET&rsquo;s garbage collector, developed a Conservative GC within the team. At that time, the CLR did not exist, and Patrick was working on the JVM.</p><p>Initially, Microsoft aimed to implement its version of the JVM instead of creating something akin to the current .NET runtime. However, once the CLR team was formed, they realized that the JVM imposed certain limitations on them, prompting the creation of their own environment.</p><p>With this decision, Patrick redeveloped a new GC from scratch, targeting the &ldquo;best GC possible&rdquo; concept, using LISP, his language of expertise. He then wrote a transpiler from LISP to C++ to make the code compatible with Microsoft&rsquo;s runtime. (<a href=https://docs.microsoft.com/en-us/archive/blogs/patrick_dussud/how-it-all-startedaka-the-birth-of-the-clr>The birth of the CLR</a>)</p><p>The current codes for the garbage collector used in .NET can be accessed from <a href=https://github.com/dotnet/runtime/blob/master/src/coreclr/src/gc/gc.cpp>this file</a> in Microsoft&rsquo;s runtime repository. Today, Maoni Stephens, the technical lead of Microsoft&rsquo;s GC team, who has written and presented many conferences and articles on various aspects of GC implementation, can be followed on <a href=https://devblogs.microsoft.com/dotnet/author/maoni>her blog</a>.</p><hr><p>Currently, .NET is equipped with three modes (flavors) of GC, each optimized for different types of applications. Let&rsquo;s dive into each of these:</p><h2 id=server-gc>Server GC</h2><p>Optimized for server-side applications like ASP.NET Core and WCF, this variant of GC is designed for environments with high request rates and frequent object allocations and deallocations.</p><p>Server GC operates with a separate heap and a GC thread for each processor. This means that if you have an eight-core processor, there will be an independent heap and GC thread on each core during garbage collection.</p><p>This approach ensures the collection process is as swift as possible without additional pauses, preventing the application from &ldquo;freezing&rdquo;.</p><p>Server GC is only executable on multi-core processors. Attempting to run a server-side application in Server GC mode on a single-core processor will automatically result in a fallback to <strong>Non-Concurrent Workstation GC</strong>.</p><p>To use Server GC in non-server-side applications (like WPF, Windows Services, etc.) on multi-core processors, add the following settings to your app.config or web.config:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;configuration&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;runtime&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;gcServer</span> <span style=color:#a6e22e>enabled=</span><span style=color:#e6db74>&#34;true&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/runtime&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/configuration&gt;</span>
</span></span></code></pre></div><p>In .NET Core applications, these settings can be added to your csproj file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>&lt;PropertyGroup&gt;
</span></span><span style=display:flex><span>  &lt;ServerGarbageCollection&gt;<span style=color:#66d9ef>true</span>&lt;/ServerGarbageCollection&gt;
</span></span><span style=display:flex><span>&lt;/PropertyGroup&gt;
</span></span></code></pre></div><hr><h2 id=concurrent-workstation-gc>Concurrent Workstation GC</h2><p>This default mode is primarily used in Windows Forms and Windows Service applications. It&rsquo;s optimized for scenarios where the application should not pause or become unresponsive, even momentarily, during garbage collection.</p><p>To enable Concurrent Workstation GC, include these settings in your application&rsquo;s config:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;configuration&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;runtime&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;gcConcurrent</span> <span style=color:#a6e22e>enabled=</span><span style=color:#e6db74>&#34;true&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/runtime&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/configuration&gt;</span>
</span></span></code></pre></div><hr><h2 id=non-concurrent-workstation-gc>Non-Concurrent Workstation GC</h2><p>Similar to Server GC, this mode conducts the collection on the thread that requests the object allocation.</p><p>For example:</p><p><strong>•</strong> Thread one requests the allocation of a 10000-character string.</p><p><strong>•</strong> The memory lacks sufficient space, triggering the garbage collector to free up the required space.</p><p><strong>•</strong> The CLR suspends all threads, the garbage collector begins its operation on the <strong>initiating thread</strong>, collecting unused objects.</p><p><strong>•</strong> Once the collection is complete, all previously suspended threads resume their operations.</p><p>This GC mode is recommended for server-side applications running on single-core processors. To activate it, modify the config settings of your application as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;configuration&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;runtime&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;gcConcurrent</span> <span style=color:#a6e22e>enabled=</span><span style=color:#e6db74>&#34;false&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/runtime&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/configuration&gt;</span>
</span></span></code></pre></div><hr><p>The following table will assist in selecting the appropriate GC settings based on the nature of your application (in most cases, the default settings are optimal, and manual adjustments to GC are unnecessary):</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>Concurrent Workstation</th><th style=text-align:center>Non-Concurrent Workstation</th><th style=text-align:center>Server GC</th></tr></thead><tbody><tr><td style=text-align:center><b>Design Goal</b></td><td style=text-align:center><span dir=ltr>Balance throughput and responsiveness for client apps with UI.</span></td><td style=text-align:center><span dir=ltr>Maximize throughput on single-processor machines.</span></td><td style=text-align:center><span dir=ltr>Maximize throughput on multi-processor machines for server apps that create multiple threads to handle the same types of requests.</span></td></tr><tr><td style=text-align:center><b>Number of Heaps</b></td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center><span dir=ltr>1 per processor ( hyper thread aware )</span></td></tr><tr><td style=text-align:center><b>GC Threads</b></td><td style=text-align:center><span dir=ltr>The thread which performs the allocation that triggers the GC.</span></td><td style=text-align:center><span dir=ltr>The thread which performs the allocation that triggers the GC.</span></td><td style=text-align:center><span dir=ltr>1 dedicated GC thread per processor</span></td></tr><tr><td style=text-align:center><b>Execution Engine Suspension</b></td><td style=text-align:center><span dir=ltr>EE is suspended much shorter but several times during a GC.</span></td><td style=text-align:center><span dir=ltr>EE is suspended during a GC.</span></td><td style=text-align:center><span dir=ltr>EE is suspended during a GC.</span></td></tr><tr><td style=text-align:center><b>Config Setting</b></td><td style=text-align:center><gcconcurrent enabled=true></td><td style=text-align:center><gcconcurrent enabled=false></td><td style=text-align:center><gcserver enabled=true></td></tr><tr><td style=text-align:center><b>On a single processor (fallback)</b></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>Non-Concurrent Workstation GC</td></tr></tbody></table></div><hr><div class=footer><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script type=text/javascript>hljs.configure({languages:[]}),hljs.initHighlightingOnLoad()</script><h2>Comments</h2><div id=disqus_thread></div><script type=text/javascript>(function(){if(location.hostname==="localhost"||location.hostname==="127.0.0.1"||location.hostname==="")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="moientajik",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></body></html>