<!doctype html><html lang=en class="wf-firasans-n4-active wf-active"><head><link href=http://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.121.0"><title>C# Garbage Collector - Part 2 &#183; Moien Tajik</title>
<meta content="Moien Tajik" property="og:site_name"><meta content="C# Garbage Collector - Part 2 - Moien Tajik" property="og:title"><meta content="In this series of articles, we aim to dive into Memory Management in C#, acquaint ourselves with the Garbage Collector, and gain an overall understanding of how it operates." property="og:description"><meta content="./Heap.jpg" property="og:image"><link href="https://fonts.googleapis.com/css?family=Fira+Sans:300,300i,400,400i|Roboto+Mono:300,300i,400,400i" rel=stylesheet><style media=print>.sidebar{display:none!important}.container,.content{width:100%;float:none;display:initial;margin:0 auto}.container{padding-left:1rem;padding-right:1rem}</style><link rel=stylesheet href=/css/poole.css><link rel=stylesheet href=/css/hyde.css><link rel=stylesheet href=/css/custom.css><script defer src=https://use.fontawesome.com/releases/v5.0.13/js/all.js integrity=sha384-xymdQtn1n3lH2wcu0qhcdaOpQwyoarkgLVxC/wZ5q7h9gHtxICrpcaSUfygqZGOe crossorigin=anonymous></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body class=theme-base-te><div class=sidebar><div class="container text-center"><div class="sidebar-about text-center"><img src=/img/Moien%20Tajik.png alt="Moien Tajik's Image" class="img-circle headshot center">
<a href=/ class=no-decoration><h1 class=brand>Moien Tajik</h1></a><p class=lead>Principal Software Engineer</p></div><div><ul class=sidebar-nav><li><a href=/><span>Home</span></a></li><li><a href=/posts/><span>Posts</span></a></li><li><a href=/tags/><span>Tags</span></a></li></li></ul></div><p><section class="row text-center"><a href=https://twitter.com/MoienTajik><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a>
&nbsp;<a href=https://github.com/MoienTajik><i class="fab fa-github fa-lg" aria-hidden=true></i></a>
&nbsp;<a href=https://linkedin.com/in/MoienTajik><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a>
&nbsp;<a href=https://stackoverflow.com/story/moientajik><i class="fab fa-stack-overflow fa-lg" aria-hidden=true></i></a>
&nbsp;<a href=https://medium.com/@MoienTajik><i class="fab fa-medium fa-lg" aria-hidden=true></i></a>
&nbsp;<a href=mailto:moientajik@hotmail.com><i class="fas fa-at fa-lg" aria-hidden=true></i></a></section></p><p class=copyright>&copy; 2024 Moien Tajik</br><a href=https://creativecommons.org/licenses/by/4.0>All rights reserved</a></p></div><div></div></div><div class="content container"><div class=post><h1 class=postTitle>C# Garbage Collector - Part 2</h1><div class="col-sm-12 col-md-12"><span class="text-left post-date meta"><i class="fas fa-calendar-alt"></i> <span class=subtitle>Publish Date: Dec 12, 2019</span><br><i class="fas fa-tags"></i>
Tags:
<a class=meta href=/tags/c>c#</a>
,
<a class=meta href=/tags/csharp>csharp</a>
,
<a class=meta href=/tags/garbage-collector>garbage collector</a>
,
<a class=meta href=/tags/gc>gc</a><br></span></div><hr><p>In this article, we will explore the differences between <strong>Stack</strong> and <strong>Heap</strong> in memory, particularly in the context of C#.</p><p>In simple terms, when you create a new variable, depending on its type, the &ldquo;value&rdquo; of your variable will be stored in either the Stack or the Heap.</p><hr><h2 id=stack>Stack</h2><p>The Stack is a data structure where data is stored linearly and operates on a <strong>LIFO</strong> (Last In, First Out) basis, meaning the last data item put in the Stack is the first one that can be accessed. When we put data in the Stack, we <strong>Push</strong> it, and when we read the last data due to its linear structure, we <strong>Pop</strong> it.</p><br><img src=./Stack.png height=450px alt=Stack style=margin:auto><br><p>This data structure is kept in memory, and many of the variables we create in our code are stored in this type of memory structure.</p><p>A variable&rsquo;s value is stored in the Stack if it is of value type. In C#, generally structs and enums are value types and are stored in the Stack by default. All value types in C# implicitly inherit from <a href=https://docs.microsoft.com/en-us/dotnet/api/system.valuetype>System.ValueType</a>.</p><p>Below are the default value types defined in C# known as Simple Types:</p><table><thead><tr><th style=text-align:center>Type</th><th style=text-align:center>Represents</th></tr></thead><tbody><tr><td style=text-align:center>bool</td><td style=text-align:center>Boolean value</td></tr><tr><td style=text-align:center>integer</td><td style=text-align:center>8-bit unsigned integer</td></tr><tr><td style=text-align:center>char</td><td style=text-align:center>16-bit Unicode character</td></tr><tr><td style=text-align:center>decimal</td><td style=text-align:center>128-bit precise decimal values with 28-29 significant digits</td></tr><tr><td style=text-align:center>double</td><td style=text-align:center>64-bit double-precision floating point type</td></tr><tr><td style=text-align:center>float</td><td style=text-align:center>32-bit single-precision floating point type</td></tr><tr><td style=text-align:center>int</td><td style=text-align:center>32-bit signed integer type</td></tr><tr><td style=text-align:center>long</td><td style=text-align:center>64-bit signed integer type</td></tr><tr><td style=text-align:center>sbyte</td><td style=text-align:center>8-bit signed integer type</td></tr><tr><td style=text-align:center>short</td><td style=text-align:center>16-bit signed integer type</td></tr><tr><td style=text-align:center>uint</td><td style=text-align:center>32-bit unsigned integer type</td></tr><tr><td style=text-align:center>ulong</td><td style=text-align:center>64-bit unsigned integer type</td></tr><tr><td style=text-align:center>ushort</td><td style=text-align:center>16-bit unsigned integer type</td></tr></tbody></table><p>If you check the source of any of these types, like <a href=https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Int32.cs>Int32</a>, in Microsoft&rsquo;s CoreFX repository, you will find that all these types are defined as Structs, which by default, are stored in the Stack.</p><p>The lifetime of variables stored in the Stack is limited to the end of the execution of a method. This means that once a method execution is completed, all the variables used in that method are automatically removed from the Stack. The type and size of values for variables stored in the Stack are determined during Compile-Time.</p><p>Local variables, method input parameters, and a method&rsquo;s return value are examples of items whose values are stored in the Stack:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> Add(<span style=color:#66d9ef>int</span> number1, <span style=color:#66d9ef>int</span> number2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// number1 is on the stack (function parameter)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// number2 is on the stack (function parameter)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sum = number1 + number2;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// sum is on the stack (local variable)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><br><p>In C#, during compile-time, the code is translated into IL (Intermediate Language), also known as MSIL (Microsoft Intermediate Language) or CIL (Common Intermediate Language). The structure of this language is stack-based, and understanding it helps us better comprehend the concept of the Stack.</p><p>IL is the language understood and executed by CLR (Common Language Runtime), which is Microsoft&rsquo;s runtime. The source for Microsoft&rsquo;s runtime, formerly known as <a href=https://github.com/dotnet/coreclr>CoreCLR</a> and now simply as Runtime, is open-source and available <a href=https://github.com/dotnet/runtime>here</a>.</p><p>Using programs like <a href=https://www.jetbrains.com/decompiler>dotPeek</a>, <a href=https://github.com/0xd4d/dnSpy>dnSpy</a>, <a href=https://learn.microsoft.com/en-us/dotnet/framework/tools/ildasm-exe-il-disassembler>ILDASM</a>, or online tools like <a href=https://sharplab.io>Sharplab</a>, you can view the IL code of your program&rsquo;s DLLs. These tools are similar, with dnSpy having the advantage of IL code debugging capabilities, and ILDASM is accessible without additional software installation through Visual Studio:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>C:<span style=color:#960050;background-color:#1e0010>\</span>Program Files (x86)<span style=color:#960050;background-color:#1e0010>\</span>Microsoft SDKs<span style=color:#960050;background-color:#1e0010>\</span>Windows<span style=color:#960050;background-color:#1e0010>\</span>{version}<span style=color:#960050;background-color:#1e0010>\</span>Bin<span style=color:#960050;background-color:#1e0010>\</span>ildasm.exe
</span></span></code></pre></div><br><p>As mentioned earlier, the lifespan of the Stack is limited to the duration of a method. The Stack created when calling a method, which includes the method&rsquo;s inputs, local variables, and return address, is known as a <strong>Stack Frame</strong> or <strong>Activation Frame</strong>.</p><br><img src=./Stack-Structure.png height=400px alt="Stack Structure" style=margin:auto><br><p>If we call the above <code>Add</code> method with parameters 2 and 5, the resulting IL output will be as follows (parts of the output have been omitted for simplicity):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>.method <span style=color:#66d9ef>private</span> hidebysig <span style=color:#66d9ef>static</span> int32 Add(int32 number1, int32 number2) cil managed
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  .locals <span style=color:#66d9ef>init</span> (int32 V_0, int32 V_1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IL_0001:  ldarg.<span style=color:#ae81ff>0</span> <span style=color:#75715e>// Stack is: [2]</span>
</span></span><span style=display:flex><span>  IL_0002:  ldarg.<span style=color:#ae81ff>1</span> <span style=color:#75715e>// Stack is: [2, 5]</span>
</span></span><span style=display:flex><span>  IL_0003:  <span style=color:#66d9ef>add</span>     <span style=color:#75715e>// Stack is: [7]</span>
</span></span><span style=display:flex><span>  IL_0004:  stloc.<span style=color:#ae81ff>0</span> <span style=color:#75715e>// Stack is: [] and V_0&#39;s value is: 7</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IL_0005:  ldloc.<span style=color:#ae81ff>0</span> <span style=color:#75715e>// Stack is: [7]</span>
</span></span><span style=display:flex><span>  IL_0006:  stloc.<span style=color:#ae81ff>1</span> <span style=color:#75715e>// Stack is: [] and V_1&#39;s value is: 7</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IL_0009:  ldloc.<span style=color:#ae81ff>1</span> <span style=color:#75715e>// Stack is: [7]</span>
</span></span><span style=display:flex><span>  IL_000a:  ret     <span style=color:#75715e>// Return [7]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You can find a list of instructions used in CIL <a href=https://en.wikipedia.org/wiki/List_of_CIL_instructions>here</a>.</p><p>Let&rsquo;s analyze the output line by line:</p><p><strong>1.</strong> In IL, you can store values resulting from computations or other methods in local variables, but first you have to declare them at the beginning.</p><ul><li>Using <code>locals</code> (which stands for local variables), you can define the necessary variables for the lifetime of the method. Naming these variables (not mandatory, like <code>V_0</code> and <code>V_1</code>) is used for readability.</li></ul><p><strong>2.</strong> The keyword <code>ldarg</code> (Load Argument) is used to load the method&rsquo;s input parameter into the Stack.</p><ul><li><code>ldarg.0</code> means loading the first input parameter into the Stack, resulting in a Stack Frame with one member, the value 2.</li><li><code>ldarg.1</code> means loading the second input parameter into the Stack, resulting in a Stack Frame with two members, values 2 and 5.</li></ul><p><strong>3.</strong> Using the keyword <code>add</code>, the values in the Stack are added together, resulting in a Stack Frame with one member, value 7.</p><p><strong>4.</strong> The keyword <code>stloc</code> (Store Local) is used to store the last member in the Stack into the specified local variable.</p><ul><li><code>stloc.0</code> means storing the last value in the Stack, number 7, into variable 0, i.e., <code>V_0</code>.</li></ul><p><strong>5.</strong> The keyword <code>ldloc</code> (Load Local) is used to load a stored local variable into the Stack.</p><ul><li><code>ldloc.0</code> means loading the stored value of local variable 0, <code>V_0</code>, into the Stack.</li></ul><p><strong>6.</strong> Finally, the value 7, stored in variable 1 or <code>V_1</code>, is again stored, loaded with <code>ldloc.1</code>, and returned with the <code>ret</code> instruction.</p><p><strong>* Note:</strong> If you have examined the codes carefully, you might wonder why there is a need to create an additional variable and store the result in it before returning it in step 6. In C#, your codes are optimized during Release build and JIT-compilation, and one of these optimization steps includes removing these extra variables, so there&rsquo;s no need to worry.</p><p><strong>* Note:</strong> By now, you might understand why a <code>StackOverflowException</code> occurs. Stack space is limited. This <a href=https://stackoverflow.com/a/28658130/6661314>space</a> is 1 megabyte in 32-bit systems and 4 megabytes in 64-bit systems. If the volume of variables pushed onto the Stack exceeds these limits, or if a method continuously calls itself (recursion) without ever exiting, you will encounter a <code>StackOverflowException</code>.</p><hr><h2 id=heap>Heap</h2><br><img src=./Heap.jpg height=450px alt=Heap style=margin:auto><div style=text-align:center><span style=font-style:italic;text-color:gray>Heap: a group of things placed, thrown, or lying one on another.</span></div><br><p>Contrary to the orderly and sequential structure of the Stack, we have the Heap. The Heap is a part of memory that doesn&rsquo;t have a specific structure, order, or layout.</p><p>Unlike the Stack, which is limited to a method, the Heap is global and accessible anywhere in the program. Memory allocation in the Heap is dynamic, and any data type can be stored at any time.</p><p>Strings are an example of types stored in the Heap. It&rsquo;s important to note that when we say &ldquo;stored,&rdquo; we refer to the <strong>value</strong> of a variable.</p><p>When we create a string variable, its value is stored in the Heap, and the memory address of that variable on the Heap is stored in the Stack:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> SayHi()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> name = <span style=color:#e6db74>&#34;Moien&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this example, since <a href=https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/String.cs>string is a class</a>, its value is stored in the heap, and the address of that memory segment is placed on the Stack:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>.method <span style=color:#66d9ef>private</span> hidebysig <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> SayHi() cil managed
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  .locals <span style=color:#66d9ef>init</span> (<span style=color:#66d9ef>string</span> V_0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IL_0001:  ldstr      <span style=color:#e6db74>&#34;Moien&#34;</span> <span style=color:#75715e>// Stack is: [memory-address of string in heap]</span>
</span></span><span style=display:flex><span>  IL_0006:  stloc.<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IL_0007:  ret
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Variables whose values are stored in the Heap are known as reference types.</p><p><strong>*Note:</strong> In this example, a variable named name is created but not used. During JIT compilation, due to the optimizations at the runtime level, this method will be deemed redundant and ignored.</p><br><img src=./Heap.png height=450px alt="Heap Structure" style=margin:auto><br><hr><h2 id=boxing>Boxing</h2><p>The process of converting a value type, such as int, which is typically stored in the Stack, into an object stored in the Heap, is known as <strong>Boxing</strong>. This action causes allocation on the memory, which is quite costly.</p><p>By performing boxing, we can store a number, contrary to its usual practice, on the heap:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Boxing()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> number = <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>object</span> boxedNumber = number;          <span style=color:#75715e>// implicit boxing using implicit cast</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>object</span> boxedNumber = (<span style=color:#66d9ef>object</span>)number;  <span style=color:#75715e>// explicit boxing using direct cast</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Initially, the number 5 was stored on the Stack, but by boxing it, i.e., placing its value inside an object, the value is transferred from the stack to the heap, causing allocation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>.method <span style=color:#66d9ef>public</span> hidebysig <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Boxing() cil managed
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  .locals <span style=color:#66d9ef>init</span> (<span style=color:#66d9ef>object</span> V_0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IL_0001:  ldc.i4.<span style=color:#ae81ff>5</span>                                <span style=color:#75715e>// Stack is: [5]</span>
</span></span><span style=display:flex><span>  IL_0002:  box        [System.Runtime]System.Int32 <span style=color:#75715e>// Stack is: [memory-address of 5 in heap]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IL_0007:  stloc.<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  IL_0008:  ret
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=unboxing>Unboxing</h2><p>The reverse of this process, i.e., converting a reference type to a value type, is known as <strong>Unboxing</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Unboxing()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>object</span> boxedNumber = <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> number = (<span style=color:#66d9ef>int</span>)boxedNumber;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The result of which will be as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>.method <span style=color:#66d9ef>public</span> hidebysig <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Unboxing() cil managed
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  .locals <span style=color:#66d9ef>init</span> (<span style=color:#66d9ef>object</span> V_0, int32 V_1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IL_0001:  ldc.i4.<span style=color:#ae81ff>5</span>                                  <span style=color:#75715e>// Stack is: [5]</span>
</span></span><span style=display:flex><span>  IL_0002:  box        [System.Runtime]System.Int32   <span style=color:#75715e>// Stack is: [memory-address of 5 in heap]</span>
</span></span><span style=display:flex><span>  IL_0007:  stloc.<span style=color:#ae81ff>0</span>                                   <span style=color:#75715e>// Stack is: []</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IL_0008:  ldloc.<span style=color:#ae81ff>0</span>                                   <span style=color:#75715e>// Stack is: [memory-address of 5 in heap]</span>
</span></span><span style=display:flex><span>  IL_0009:  unbox.any  [System.Runtime]System.Int32   <span style=color:#75715e>// Stack is: [5]</span>
</span></span><span style=display:flex><span>  IL_000e:  stloc.<span style=color:#ae81ff>1</span>                                   <span style=color:#75715e>// Stack is: []</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IL_000f:  ret
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><br><p>Recent efforts by dotnet team have led to a remarkable improvement in performance in both .NET Core and ASP.NET Core. A key reason behind this enhanced performance is the significant reduction of memory allocations in the .NET codebase.</p><p>Unlike the stack, where the lifespan of variables ends at the conclusion of a method, variables allocated in the heap do <strong>not</strong> follow this pattern. If these variables are not manually deleted, they remain in memory for the duration of the program&rsquo;s execution. This is where the <strong>Garbage Collector</strong> in .NET comes into play.</p></div><hr><div class=footer><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script type=text/javascript>hljs.configure({languages:[]}),hljs.initHighlightingOnLoad()</script><h2>Comments</h2><div id=disqus_thread></div><script type=text/javascript>(function(){if(location.hostname==="localhost"||location.hostname==="127.0.0.1"||location.hostname==="")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="moientajik",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></body></html>