<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Moien Tajik</title><link>/posts/</link><description>Recent content in Posts on Moien Tajik</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 10 Jan 2020 20:00:00 +0330</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>C# Garbage Collector - Part 3</title><link>/posts/2020-01-10-gc-part-3/</link><pubDate>Fri, 10 Jan 2020 20:00:00 +0330</pubDate><guid>/posts/2020-01-10-gc-part-3/</guid><description>&lt;p>This article in the C# garbage collector series outlines the history and types of GC in .NET. It covers three GC modes: &lt;br>&lt;/p>
&lt;ol> &lt;li>&lt;b>Server GC&lt;/b> for server-side applications&lt;/li> &lt;li>&lt;b>Concurrent Workstation GC&lt;/b> for client apps with UI&lt;/li> &lt;li>&lt;b>Non-Concurrent Workstation GC&lt;/b> for single-processor server apps&lt;/li> &lt;/ol>
Each mode is optimized for different scenarios, balancing throughput and responsiveness. The article provides insights into configuring these modes for specific applications, highlighting the importance of choosing the right GC mode based on the application's nature and environment.</description></item><item><title>C# Garbage Collector - Part 2</title><link>/posts/2019-12-12-gc-part-2/</link><pubDate>Thu, 12 Dec 2019 23:00:00 +0330</pubDate><guid>/posts/2019-12-12-gc-part-2/</guid><description>This article delves into the distinction between &lt;strong>Stack&lt;/strong> and &lt;strong>Heap&lt;/strong> in C# memory management. It explains how the stack, with its &lt;code>LIFO&lt;/code> method, stores value types like structs and enums, while the heap handles reference types like &lt;code>strings&lt;/code>. Key concepts like &lt;strong>boxing&lt;/strong> and &lt;strong>unboxing&lt;/strong> are covered, showing how value types can be converted to reference types and vice versa. The article emphasizes the importance of efficient memory management and the role of the garbage collector in .NET, particularly in managing heap memory and optimizing overall application performance.</description></item><item><title>C# Garbage Collector - Part 1</title><link>/posts/2019-11-29-gc-part-1/</link><pubDate>Fri, 29 Nov 2019 21:00:00 +0330</pubDate><guid>/posts/2019-11-29-gc-part-1/</guid><description>This article explores memory management in C# and the garbage collector&amp;rsquo;s role. It differentiates &lt;strong>managed&lt;/strong> languages like C# from &lt;strong>unmanaged&lt;/strong> ones like C and C++, highlighting C#&amp;rsquo;s automatic memory management. Using a simple example, the article shows how C# frees developers from the complexities of manual memory allocation and disposal, allowing them to focus more on business logic. The series aims to provide a comprehensive understanding of the garbage collector in C#, demonstrating its efficiency in managing memory in managed programming environments.</description></item><item><title>C# Internals - Single and SingleOrDefault</title><link>/posts/2019-10-16-csharp-internals-single/</link><pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate><guid>/posts/2019-10-16-csharp-internals-single/</guid><description>This article demystifies the LINQ methods &lt;code>Single&lt;/code> and &lt;code>SingleOrDefault&lt;/code> in C#, addressing the misconception that they always traverse an entire &lt;code>Enumerable&lt;/code>. It explains the actual behavior of these methods, both with and without a predicate, contrasting them with &lt;code>First&lt;/code> and &lt;code>FirstOrDefault&lt;/code>. The article clarifies that &lt;code>SingleOrDefault&lt;/code> efficiently handles different scenarios, such as returning a default value, the only item, or throwing an error when multiple items exist. It emphasizes the operational differences and efficiency &lt;strong>O(1)&lt;/strong> without predicate and &lt;strong>O(N)&lt;/strong> with predicate of these methods, offering valuable insights for C# developers seeking to optimize their code.</description></item><item><title>Implementing CQRS with MediatR - Part 5</title><link>/posts/2019-02-24-mediatr-part-5/</link><pubDate>Sun, 24 Feb 2019 00:00:00 +0330</pubDate><guid>/posts/2019-02-24-mediatr-part-5/</guid><description>Part 5 of the CQRS with MediatR series introduces &lt;em>Event Sourcing&lt;/em> using &lt;strong>EventStore&lt;/strong>. It focuses on integrating EventStore into an ASP.NET Core application, highlighted by creating the &lt;code>EventStoreDbContext&lt;/code> class. The tutorial showcases the &lt;code>EventLoggerBehavior&lt;/code> in MediatR for logging Command actions and responses, utilizing a &lt;strong>Convention over Configuration&lt;/strong> approach. This part provides a practical guide for effectively tracking and understanding system state changes in a CQRS application through event history.</description></item><item><title>Implementing CQRS with MediatR - Part 4</title><link>/posts/2019-02-11-mediatr-part-4/</link><pubDate>Mon, 11 Feb 2019 00:00:00 +0330</pubDate><guid>/posts/2019-02-11-mediatr-part-4/</guid><description>In this part of the CQRS with MediatR series, &lt;em>behaviors&lt;/em> in MediatR are introduced for &lt;strong>aspect-oriented programming&lt;/strong>. The tutorial covers two specific behaviors: &lt;br> &lt;li>Performance counter behavior: for logging method execution times.&lt;/li> &lt;li>Transaction behavior: for managing database transactions and rollbacks.&lt;/li>&lt;br> Both are implemented using the &lt;code>IPipelineBehavior&lt;/code> interface, demonstrating how to write reusable, efficient code that adheres to the &lt;strong>DRY&lt;/strong> principle. The article provides practical examples and code snippets, showing how these behaviors enhance functionality and error handling in an ASP.NET Core application.</description></item><item><title>Implementing CQRS with MediatR - Part 3</title><link>/posts/2019-02-02-mediatr-part-3/</link><pubDate>Sat, 02 Feb 2019 00:00:00 +0330</pubDate><guid>/posts/2019-02-02-mediatr-part-3/</guid><description>Part 3 of the CQRS with MediatR series focuses on adding validation and event handling. Fluent Validation is introduced to validate commands, followed by the use of &lt;code>INotification&lt;/code> and &lt;code>INotificationHandler&lt;/code> for event handling, illustrated with a &lt;code>CustomerCreatedEvent&lt;/code>. This setup allows for separate event handlers for different actions like email notifications and logging, adhering to the &lt;strong>Single Responsibility Principle&lt;/strong>. The tutorial provides code examples for integrating these features into an ASP.NET Core application, setting the stage for the next part on MediatR behaviors and aspect-oriented programming.</description></item><item><title>Implementing CQRS with MediatR - Part 2</title><link>/posts/2019-01-27-mediatr-part-2/</link><pubDate>Sun, 27 Jan 2019 00:00:00 +0330</pubDate><guid>/posts/2019-01-27-mediatr-part-2/</guid><description>Discover the practical implementation of the CQRS pattern using MediatR in ASP.NET Core. This tutorial guides you through setting up MediatR, creating commands and queries with the &lt;code>IRequest&lt;/code> interface, and handling them with &lt;code>IRequestHandler&lt;/code>. It features a real-world example of adding a customer to a database, showcasing command creation, immutability, and the use of Entity Framework and AutoMapper. The article emphasizes decoupling in request handling, aligning with the &lt;strong>Hollywood Principle&lt;/strong>, and provides a glimpse into future topics like Fluent Validation. A must-read for developers looking to enhance their CQRS skills.</description></item><item><title>Implementing CQRS with MediatR - Part 1</title><link>/posts/2019-01-21-mediatr-part-1/</link><pubDate>Mon, 21 Jan 2019 00:00:00 +0330</pubDate><guid>/posts/2019-01-21-mediatr-part-1/</guid><description>This article dives into the implementation of the &lt;strong>CQRS&lt;/strong> design pattern using the MediatR library in .NET, simplifying its complexity. It explains the division of application methods into &lt;code>Command&lt;/code> and &lt;code>Query&lt;/code> functions, highlighting the benefits of this separation for technology choice and scalability. The piece also touches on the concept of events and &lt;strong>Event Sourcing&lt;/strong>, showcasing their roles in maintaining system states and facilitating troubleshooting. The use of the &lt;strong>Event Store&lt;/strong> database for implementing Event Sourcing is briefly introduced, offering a comprehensive view of the CQRS pattern and its practical application.</description></item><item><title>Design Patterns - Mediator</title><link>/posts/2019-01-19-mediator-design-pattern/</link><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><guid>/posts/2019-01-19-mediator-design-pattern/</guid><description>Explore the Mediator design pattern, illustrated through an airport control tower analogy. Learn how it manages communications between planes in &lt;strong>C#&lt;/strong>, starting from the &lt;code>IAirTrafficControl&lt;/code> interface to the implementation of &lt;code>AirbusAirplane&lt;/code> and &lt;code>BoeingAirplane&lt;/code> classes. The article concludes with the &lt;code>JFKAirTrafficControl&lt;/code> class, demonstrating the pattern&amp;rsquo;s role in facilitating effective object interaction. Ideal for those interested in applying design patterns in software engineering.</description></item><item><title>API Versioning in ASP.NET Core</title><link>/posts/2018-11-12-aspnetcore-api-versioning/</link><pubDate>Mon, 12 Nov 2018 00:00:00 +0330</pubDate><guid>/posts/2018-11-12-aspnetcore-api-versioning/</guid><description>This article guides on implementing API versioning in ASP.NET Core, highlighting its simplicity compared to ASP.NET Web API. It covers installing the &lt;code>Microsoft.AspNetCore.Mvc.Versioning&lt;/code> package, setting up default versioning, and various versioning methods including &lt;strong>URL path segment&lt;/strong> and &lt;strong>header versioning&lt;/strong>. &lt;br>&lt;br> The article also discusses deprecating older API versions and excluding specific controllers from versioning using the &lt;code>ApiVersionNeutral&lt;/code> attribute. The process is illustrated with concise examples and code snippets, offering a practical approach to API versioning in ASP.NET Core applications.</description></item><item><title>Route constraints in ASP.NET Core</title><link>/posts/2018-11-09-aspnetcore-route-constraints/</link><pubDate>Fri, 09 Nov 2018 00:00:00 +0330</pubDate><guid>/posts/2018-11-09-aspnetcore-route-constraints/</guid><description>&lt;p>This article covers implementing &lt;strong>route constraints&lt;/strong> in ASP.NET Core to validate route parameter values. It highlights two methods:&lt;/p>
&lt;ol> &lt;li>Inline constraints: using route templates directly&lt;/li> &lt;li>MapRoute constraints: using classes that follow the &lt;code>IRouteConstraint&lt;/code> interface&lt;/li> &lt;/ol>
The article also describes creating custom constraints for specific validation needs, such as checking if a string starts with a particular value. This feature in ASP.NET Core ensures that only valid values are passed to action methods, enhancing API reliability and functionality.</description></item><item><title>Getting Started with DebuggerTypeProxy in Visual Studio</title><link>/posts/2018-07-05-debuggertypeproxy/</link><pubDate>Thu, 05 Jul 2018 00:00:00 +0330</pubDate><guid>/posts/2018-07-05-debuggertypeproxy/</guid><description>The article explains the use of &lt;code>DebuggerTypeProxy&lt;/code> in Visual Studio for enhancing debugging. It illustrates how to display complex or less readable properties (like &lt;strong>Hex&lt;/strong> values) in a more understandable format using a proxy class. By applying the &lt;code>DebuggerTypeProxy&lt;/code> attribute to a class, the values are shown in the debugger in a customized way, as defined in the proxy class. This feature significantly improves the &lt;strong>debugging experience&lt;/strong> by providing clearer insights into the data structures being inspected.</description></item><item><title>Generate random data using GenFu in C#</title><link>/posts/2018-07-03-genfu/</link><pubDate>Tue, 03 Jul 2018 00:00:00 +0330</pubDate><guid>/posts/2018-07-03-genfu/</guid><description>Sometimes, a great deal of time is wasted and a large amount of redundant code is generated when creating random data, especially when writing tests. A library named GenFu has been created that takes on the responsibility of creating random data. This library is open source, and you can find its source code on GitHub.</description></item></channel></rss>